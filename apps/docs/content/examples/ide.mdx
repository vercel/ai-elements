---
title: IDE
description: An example of how to use the AI Elements to build an AI-powered IDE.
full: true
---

An example of how to use the AI Elements to build an AI-powered IDE with file navigation, code display, terminal output, and an integrated chat assistant.

<Preview path="demo-cursor" type="block" className="p-0" />

## Tutorial

Let's walk through how to build an AI-powered IDE using AI Elements. Our example will include a file tree, code block viewer, terminal output, task queue, and chat interface with streaming responses.

### Setup

First, set up a new Next.js repo and cd into it by running the following command (make sure you choose to use Tailwind in the project setup):

```bash title="Terminal"
npx create-next-app@latest ai-ide && cd ai-ide
```

Run the following command to install AI Elements. This will also set up shadcn/ui if you haven't already configured it:

```bash title="Terminal"
npx ai-elements@latest
```

Now, install the required dependencies:

```package-install
npm i nanoid shiki lucide-react
```

We're now ready to start building our IDE!

### Client

Let's build the IDE step by step. We'll create the component structure with a three-panel layout: file tree on the left, code and terminal in the center, and the AI chat on the right.

#### Import the components

First, import the necessary AI Elements components in your `app/page.tsx`:

```tsx title="app/page.tsx"
"use client";

import {
  Checkpoint,
  CheckpointIcon,
  CheckpointTrigger,
} from "@/components/ai-elements/checkpoint";
import {
  CodeBlock,
  CodeBlockActions,
  CodeBlockCopyButton,
  CodeBlockFilename,
  CodeBlockHeader,
  CodeBlockTitle,
} from "@/components/ai-elements/code-block";
import {
  Conversation,
  ConversationContent,
} from "@/components/ai-elements/conversation";
import {
  FileTree,
  FileTreeFile,
  FileTreeFolder,
} from "@/components/ai-elements/file-tree";
import {
  Message,
  MessageContent,
  MessageResponse,
} from "@/components/ai-elements/message";
import {
  Plan,
  PlanAction,
  PlanContent,
  PlanDescription,
  PlanHeader,
  PlanTitle,
  PlanTrigger,
} from "@/components/ai-elements/plan";
import {
  PromptInput,
  type PromptInputMessage,
  PromptInputFooter,
  PromptInputSubmit,
  PromptInputTextarea,
} from "@/components/ai-elements/prompt-input";
import {
  Queue,
  QueueItem,
  QueueItemContent,
  QueueItemIndicator,
  QueueList,
  QueueSection,
  QueueSectionContent,
  QueueSectionLabel,
  QueueSectionTrigger,
} from "@/components/ai-elements/queue";
import {
  Task,
  TaskContent,
  TaskItemFile,
  TaskTrigger,
} from "@/components/ai-elements/task";
import {
  Terminal,
  TerminalContent,
  TerminalHeader,
  TerminalTitle,
} from "@/components/ai-elements/terminal";
import { cn } from "@/lib/utils";
import type { BundledLanguage } from "shiki";
import { nanoid } from "nanoid";
import { useCallback, useEffect, useState } from "react";
import { CheckCircle2Icon, ListTodoIcon } from "lucide-react";
```

#### Define types and mock data

Create the type definitions and mock file contents for the IDE:

```tsx title="app/page.tsx"
interface MockFile {
  path: string;
  name: string;
  language: BundledLanguage;
  content: string;
}

interface MessageType {
  key: string;
  from: "user" | "assistant";
  content: string;
}

interface TaskItem {
  id: string;
  title: string;
  status: "pending" | "in_progress" | "completed";
}

const mockFiles: MockFile[] = [
  {
    path: "src/app.tsx",
    name: "app.tsx",
    language: "tsx",
    content: `import { useState } from "react";

export function App() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}`,
  },
  // Add more mock files as needed
];

const initialTasks: TaskItem[] = [
  { id: "1", title: "Refactor Button component", status: "completed" },
  { id: "2", title: "Add form validation", status: "in_progress" },
  { id: "3", title: "Write unit tests", status: "pending" },
];
```

#### Build the file tree panel

The left sidebar displays the file tree for navigation:

```tsx title="app/page.tsx"
<div className="flex w-64 flex-col border-r">
  <div className="border-b px-4 py-3">
    <h2 className="font-semibold text-sm">Explorer</h2>
  </div>
  <div className="flex-1 overflow-auto p-2">
    <FileTree
      className="border-none"
      expanded={expandedPaths}
      onExpandedChange={setExpandedPaths}
      onSelect={handleFileSelect}
      selectedPath={selectedPath}
    >
      <FileTreeFolder name="src" path="src">
        <FileTreeFolder name="components" path="src/components">
          <FileTreeFile name="button.tsx" path="src/components/button.tsx" />
          <FileTreeFile name="input.tsx" path="src/components/input.tsx" />
        </FileTreeFolder>
        <FileTreeFile name="app.tsx" path="src/app.tsx" />
      </FileTreeFolder>
      <FileTreeFile name="package.json" path="package.json" />
    </FileTree>
  </div>
</div>
```

#### Build the code and terminal panel

The center panel shows the code block and terminal output:

```tsx title="app/page.tsx"
<div className="flex flex-1 flex-col overflow-hidden">
  {/* Code Block */}
  <div className="flex-1 overflow-auto p-4">
    <CodeBlock
      code={currentFile.content}
      language={currentFile.language}
      showLineNumbers
    >
      <CodeBlockHeader>
        <CodeBlockTitle>
          <CodeBlockFilename>{currentFile.path}</CodeBlockFilename>
        </CodeBlockTitle>
        <CodeBlockActions>
          <CodeBlockCopyButton />
        </CodeBlockActions>
      </CodeBlockHeader>
    </CodeBlock>
  </div>

  {/* Terminal */}
  <div className="h-64 border-t p-4">
    <Terminal
      className="h-full"
      isStreaming={isTerminalStreaming}
      output={terminalOutput}
    >
      <TerminalHeader>
        <TerminalTitle>Build Output</TerminalTitle>
      </TerminalHeader>
      <TerminalContent className="max-h-full" />
    </Terminal>
  </div>
</div>
```

#### Build the chat panel

The right sidebar contains the plan, task queue, and chat interface:

```tsx title="app/page.tsx"
<div className="flex w-80 flex-col border-l">
  {/* Plan Section */}
  <div className="border-b p-3">
    <Plan defaultOpen>
      <PlanHeader>
        <div>
          <PlanTitle>Implementation Plan</PlanTitle>
          <PlanDescription>Adding form validation</PlanDescription>
        </div>
        <PlanAction>
          <PlanTrigger />
        </PlanAction>
      </PlanHeader>
      <PlanContent className="pt-0">
        <Task defaultOpen>
          <TaskTrigger title="Search for validation patterns" />
          <TaskContent>
            <TaskItemFile>src/utils/helpers.ts</TaskItemFile>
            <TaskItemFile>src/app.tsx</TaskItemFile>
          </TaskContent>
        </Task>
      </PlanContent>
    </Plan>
  </div>

  {/* Task Queue */}
  <div className="border-b p-3">
    <Queue>
      <QueueSection defaultOpen>
        <QueueSectionTrigger>
          <QueueSectionLabel
            count={pendingTasks.length}
            icon={<ListTodoIcon className="size-4" />}
            label="Pending"
          />
        </QueueSectionTrigger>
        <QueueSectionContent>
          <QueueList>
            {pendingTasks.map((task) => (
              <QueueItem key={task.id}>
                <div className="flex items-center gap-2">
                  <QueueItemIndicator />
                  <QueueItemContent>{task.title}</QueueItemContent>
                </div>
              </QueueItem>
            ))}
          </QueueList>
        </QueueSectionContent>
      </QueueSection>
    </Queue>
  </div>

  {/* Chat Messages */}
  <div className="flex flex-1 flex-col overflow-hidden">
    <Conversation className="flex-1">
      <ConversationContent className="gap-4 p-3">
        {messages.map((message) => (
          <Message from={message.from} key={message.key}>
            <MessageContent
              className={cn(
                message.from === "user"
                  ? "rounded-lg bg-secondary px-3 py-2"
                  : ""
              )}
            >
              {message.from === "assistant" ? (
                <MessageResponse>{message.content}</MessageResponse>
              ) : (
                message.content
              )}
            </MessageContent>
          </Message>
        ))}
        {showCheckpoint && (
          <Checkpoint>
            <CheckpointIcon />
            <CheckpointTrigger tooltip="Restore to this checkpoint">
              Checkpoint saved
            </CheckpointTrigger>
          </Checkpoint>
        )}
      </ConversationContent>
    </Conversation>

    {/* Chat Input */}
    <div className="border-t p-3">
      <PromptInput className="rounded-lg border" onSubmit={handleSubmit}>
        <PromptInputTextarea
          className="min-h-10"
          onChange={(e) => setChatText(e.target.value)}
          placeholder="Ask about the code..."
          value={chatText}
        />
        <PromptInputFooter className="justify-end p-2">
          <PromptInputSubmit
            disabled={status !== "ready" || !chatText.trim()}
            status={status === "streaming" ? "streaming" : undefined}
          />
        </PromptInputFooter>
      </PromptInput>
    </div>
  </div>
</div>
```

#### Add streaming functionality

Implement the streaming logic for chat messages and terminal output:

```tsx title="app/page.tsx"
const streamContent = useCallback(
  async (messageKey: string, content: string) => {
    const words = content.split(" ");
    let currentContent = "";

    for (let i = 0; i < words.length; i++) {
      currentContent += (i > 0 ? " " : "") + words[i];
      const finalContent = currentContent;

      setMessages((prev) =>
        prev.map((msg) =>
          msg.key === messageKey ? { ...msg, content: finalContent } : msg
        )
      );

      await new Promise((resolve) =>
        setTimeout(resolve, Math.random() * 40 + 20)
      );
    }
  },
  []
);
```

### Key Features

The IDE example demonstrates several powerful features:

- **File Tree Navigation**: The `FileTree` component displays a hierarchical file structure with expandable folders and file selection.
- **Code Display**: The `CodeBlock` component renders syntax-highlighted code with line numbers and a copy button.
- **Terminal Output**: The `Terminal` component shows streaming build output with ANSI color support.
- **Plan Component**: The `Plan` displays the AI's implementation strategy with collapsible sections.
- **Task Queue**: The `Queue` component organizes pending and completed tasks in separate sections.
- **Chat Interface**: The `Conversation` and `Message` components create a streaming chat experience.
- **Checkpoints**: The `Checkpoint` component allows users to mark and restore conversation states.
- **Streaming Support**: All components support real-time streaming for a responsive user experience.

You now have a working AI-powered IDE interface! Feel free to extend it with additional features like file editing, multiple tabs, or connect it to a real AI backend using the AI SDK.
