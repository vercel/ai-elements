---
title: Message
description: A comprehensive suite of components for displaying chat messages, including message rendering, branching, actions, and markdown responses.
path: elements/components/message
---

The `Message` component suite provides a complete set of tools for building chat interfaces. It includes components for displaying messages from users and AI assistants, managing multiple response branches, adding action buttons, and rendering markdown content.

<Preview path="message" />

<Callout type="warning">
  **Important:** After adding the component, you'll need to add the following to your `globals.css` file:

```css
@source "../node_modules/streamdown/dist/*.js";
```

This is **required** for the MessageResponse component to work properly. Without this import, the Streamdown styles will not be applied to your project. See [Streamdown's documentation](https://streamdown.ai/) for more details.

</Callout>

## Installation

<ElementsInstaller path="message" />

## Features

- Displays messages from both user and AI assistant with distinct styling and automatic alignment
- Minimalist flat design with user messages in secondary background and assistant messages full-width
- **Response branching** with navigation controls to switch between multiple AI response versions
- **Markdown rendering** with GFM support (tables, task lists, strikethrough), math equations, and smart streaming
- **Action buttons** for common operations (retry, like, dislike, copy, share) with tooltips and state management
- **File attachments** display with support for images and generic files with preview and remove functionality
- Code blocks with syntax highlighting and copy-to-clipboard functionality
- Keyboard accessible with proper ARIA labels
- Responsive design that adapts to different screen sizes
- Seamless light/dark theme integration

<Callout>
  Branching is an advanced use case you can implement to suit your needs. While
  the AI SDK does not provide built-in branching support, you have full
  flexibility to design and manage multiple response paths.
</Callout>

## Usage with AI SDK

Build a simple chat UI where the user can copy or regenerate the most recent message.

Add the following component to your frontend:

```tsx title="app/page.tsx"
"use client";

import { useState } from "react";
import {
  MessageActions,
  MessageAction,
} from "@/components/ai-elements/message";
import { Message, MessageContent } from "@/components/ai-elements/message";
import {
  Conversation,
  ConversationContent,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation";
import {
  Input,
  PromptInputTextarea,
  PromptInputSubmit,
} from "@/components/ai-elements/prompt-input";
import { MessageResponse } from "@/components/ai-elements/message";
import { RefreshCcwIcon, CopyIcon } from "lucide-react";
import { useChat } from "@ai-sdk/react";
import { Fragment } from "react";

const ActionsDemo = () => {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status, regenerate } = useChat();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim()) {
      sendMessage({ text: input });
      setInput("");
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6 relative size-full rounded-lg border h-[600px]">
      <div className="flex flex-col h-full">
        <Conversation>
          <ConversationContent>
            {messages.map((message, messageIndex) => (
              <Fragment key={message.id}>
                {message.parts.map((part, i) => {
                  switch (part.type) {
                    case "text":
                      const isLastMessage =
                        messageIndex === messages.length - 1;

                      return (
                        <Fragment key={`${message.id}-${i}`}>
                          <Message from={message.role}>
                            <MessageContent>
                              <MessageResponse>{part.text}</MessageResponse>
                            </MessageContent>
                          </Message>
                          {message.role === "assistant" && isLastMessage && (
                            <MessageActions>
                              <MessageAction
                                onClick={() => regenerate()}
                                label="Retry"
                              >
                                <RefreshCcwIcon className="size-3" />
                              </MessageAction>
                              <MessageAction
                                onClick={() =>
                                  navigator.clipboard.writeText(part.text)
                                }
                                label="Copy"
                              >
                                <CopyIcon className="size-3" />
                              </MessageAction>
                            </MessageActions>
                          )}
                        </Fragment>
                      );
                    default:
                      return null;
                  }
                })}
              </Fragment>
            ))}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>

        <Input
          onSubmit={handleSubmit}
          className="mt-4 w-full max-w-2xl mx-auto relative"
        >
          <PromptInputTextarea
            value={input}
            placeholder="Say something..."
            onChange={(e) => setInput(e.currentTarget.value)}
            className="pr-12"
          />
          <PromptInputSubmit
            status={status === "streaming" ? "streaming" : "ready"}
            disabled={!input.trim()}
            className="absolute bottom-1 right-1"
          />
        </Input>
      </div>
    </div>
  );
};

export default ActionsDemo;
```

## Props

### `<Message />`

<TypeTable
  type={{
    from: {
      description:
        'The role of the message sender ("user", "assistant", or "system").',
      type: 'UIMessage["role"]',
    },
    "...props": {
      description: "Any other props are spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageContent />`

<TypeTable
  type={{
    "...props": {
      description: "Any other props are spread to the content div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageResponse />`

<TypeTable
  type={{
    children: {
      description: "The markdown content to render.",
      type: "string",
    },
    parseIncompleteMarkdown: {
      description:
        "Whether to parse and fix incomplete markdown syntax (e.g., unclosed code blocks or lists).",
      type: "boolean",
      default: "true",
    },
    className: {
      description: "CSS class names to apply to the wrapper div element.",
      type: "string",
    },
    components: {
      description:
        "Custom React components to use for rendering markdown elements (e.g., custom heading, paragraph, code block components).",
      type: "object",
    },
    allowedImagePrefixes: {
      description:
        'Array of allowed URL prefixes for images. Use ["*"] to allow all images.',
      type: "string[]",
      default: '["*"]',
    },
    allowedLinkPrefixes: {
      description:
        'Array of allowed URL prefixes for links. Use ["*"] to allow all links.',
      type: "string[]",
      default: '["*"]',
    },
    defaultOrigin: {
      description:
        "Default origin to use for relative URLs in links and images.",
      type: "string",
    },
    rehypePlugins: {
      description:
        "Array of rehype plugins to use for processing HTML. Includes KaTeX for math rendering by default.",
      type: "array",
      default: "[rehypeKatex]",
    },
    remarkPlugins: {
      description:
        "Array of remark plugins to use for processing markdown. Includes GitHub Flavored Markdown and math support by default.",
      type: "array",
      default: "[remarkGfm, remarkMath]",
    },
    "...props": {
      description: "Any other props are spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageActions />`

<TypeTable
  type={{
    "...props": {
      description: "HTML attributes to spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageAction />`

<TypeTable
  type={{
    tooltip: {
      description: "Optional tooltip text shown on hover.",
      type: "string",
    },
    label: {
      description:
        "Accessible label for screen readers. Also used as fallback if tooltip is not provided.",
      type: "string",
    },
    "...props": {
      description:
        "Any other props are spread to the underlying shadcn/ui Button component.",
      type: "React.ComponentProps<typeof Button>",
    },
  }}
/>

### `<MessageBranch />`

<TypeTable
  type={{
    defaultBranch: {
      description: "The index of the branch to show by default.",
      type: "number",
      default: "0",
    },
    onBranchChange: {
      description: "Callback fired when the branch changes.",
      type: "(branchIndex: number) => void",
    },
    "...props": {
      description: "Any other props are spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageBranchContent />`

<TypeTable
  type={{
    "...props": {
      description: "Any other props are spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageBranchSelector />`

<TypeTable
  type={{
    from: {
      description:
        "Aligns the selector for user, assistant or system messages.",
      type: 'UIMessage["role"]',
    },
    "...props": {
      description: "Any other props are spread to the selector container.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

### `<MessageBranchPrevious />`

<TypeTable
  type={{
    "...props": {
      description:
        "Any other props are spread to the underlying shadcn/ui Button component.",
      type: "React.ComponentProps<typeof Button>",
    },
  }}
/>

### `<MessageBranchNext />`

<TypeTable
  type={{
    "...props": {
      description:
        "Any other props are spread to the underlying shadcn/ui Button component.",
      type: "React.ComponentProps<typeof Button>",
    },
  }}
/>

### `<MessageBranchPage />`

<TypeTable
  type={{
    "...props": {
      description: "Any other props are spread to the underlying span element.",
      type: "React.HTMLAttributes<HTMLSpanElement>",
    },
  }}
/>

### `<MessageAttachments />`

A container component for displaying file attachments in a message. Automatically positions attachments at the end of the message with proper spacing and alignment.

<TypeTable
  type={{
    children: {
      description:
        "MessageAttachment components to render. Returns null if no children provided.",
      type: "ReactNode",
    },
    "...props": {
      description: "Any other props are spread to the root div.",
      type: 'React.ComponentProps<"div">',
    },
  }}
/>

**Example:**

```tsx
<MessageAttachments className="mb-2">
  {files.map((attachment) => (
    <MessageAttachment data={attachment} key={attachment.url} />
  ))}
</MessageAttachments>
```

### `<MessageAttachment />`

Displays a single file attachment. Images are shown as thumbnails (96px Ã— 96px) with rounded corners. Non-image files show a paperclip icon with the filename.

<TypeTable
  type={{
    data: {
      description: "The file data to display. Must include url and mediaType.",
      type: "FileUIPart",
    },
    onRemove: {
      description:
        "Optional callback fired when the remove button is clicked. If provided, a remove button will appear on hover.",
      type: "() => void",
    },
    "...props": {
      description: "Any other props are spread to the root div.",
      type: "React.HTMLAttributes<HTMLDivElement>",
    },
  }}
/>

**Example:**

```tsx
<MessageAttachment
  data={{
    type: "file",
    url: "https://example.com/image.jpg",
    mediaType: "image/jpeg",
    filename: "image.jpg",
  }}
  onRemove={() => console.log("Remove clicked")}
/>
```
